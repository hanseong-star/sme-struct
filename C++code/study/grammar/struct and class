둘 다 사용자 정의 자료를 만드는 방법

struct는 기본적으로 public
class는 기본적으로 private

ex)

#include <iostream>
using namespace std;

struct student {
    int age;
};

class Teacher {
    int age;

public:
    void setAge(int a) { age = a };
    int getAge() {return age};

};

int main(){
    student s;
    s.age = 15 // 가능

    Teacher t;
    t.age = 40 // 에러
    t.setAge(40); // 가능
    cout << t.getAge(); //가능

}

접근에는 
public, private, protected 이렇게 세종류가 있다
1. public:
    어디서든 접근 가능
2. private:
    클래스 내부에서만 접근 가능
3. protected:
    클래스 내부 + 상속받은 자식 클래스에서 접근 가능

생성자(constructors)
    객체가 만들어질 때 자동으로 호출되는 함수
    클래스 이름과 똑같이 써야함. 반환형 없음 (void X)

소멸자(deconstructors)
    객체가 사라질 때 자동으로 호출되는 함수
    클래스 이름 앞에 ~ 붙임

ex)
class ClassName{
public:
    ClassName(매개변수들);
    ~ClassName();
}


** dynamic memory와 class를 이용한 구조 숨기고 data집어넣기 가능
ex)
class Vect {
public:
    Vect(int n) : size(n), data(new int[n]{}) {}  // 초기화 리스트 + 0으로 초기화
    ~Vect() { delete[] data; }

    int  size_of() const { return size; }         // 읽기 전용
    int& operator[](int i) { return data[i]; }    // 쓰기 가능
    const int& operator[](int i) const { return data[i]; } // 읽기 전용 오버로드

    int& at(int i) {                               // 안전 버전(범위 체크)
        if (i < 0 || i >= size) throw out_of_range("index");
        return data[i];
    }
    const int& at(int i) const {
        if (i < 0 || i >= size) throw out_of_range("index");
        return data[i];
    }

private:
    int* data;
    int  size;
};

new는 주소를 할당해줌 data가 *로 생성되어야 
new를 통해 크기가 n인 배열의 주소 시작점을 받게 됨

Vect v(3);
v[0] = 10;
v.at(1) = 20;
int x = v.at(2);
이렇게 입력하면
1. 크기가 3인 data 생성
2. int& operator[] 로 들어가 data[0]의 주소를 반환함
3. 그 주소에 10이라는 데이터를 입력함
4. data[0] = 10이 됨
5. v.at(1)로 int& at(int i) 로 들어가 범위 측정
6. data[1]의 주소 반환
7. 반환된 주소에 20 넣기
8. v.at(2)도 범위 측정 후 data[2]의 주소를 반환
9. int에 의해 값 복사가 일어나 data[2]의 값이 들어감
10. x=0이됨

data를 직접 접근하지 못함
주소를 반환하고 주소에 데이터를 집어넣으며 작동

const는 객체가 const일때 호출
변경 불가한 객체를 만들 때 사용

Vect(int n) : size(n), data(new int[n]{}) {} 의미
: 초기화 시작
size(n) size=n
new int[n] 정수 n개짜리 배열을 동적 할당
new int[n]{} 모든 요소를 0으로 초기화
{}가 value-initialization
마지막 {} 생성자 본문

차라리 
class Vect {
public:
    Vect(int n);
    ~Vect();
}

Vect::Vect(int n){
    size = n;
    data = new int[n]{};
}
로 constructors를 만들것

중요!! new를 사용했으면 delete로 꼭 지워줄것
안그러면 new로 할당한 메모리가 그대로 heap에 남게됨
메모리 누수(memory leak)라고 부름

만약 data의 값을 복사하고 싶으면
새로운 메모리를 만들어서 값만 복사하기
ex)
Vect(const Vect& other) {
    size = other.size;
    data = new int[size];            // 새 메모리 할당
    for (int i = 0; i < size; i++) 
        data[i] = other.data[i];     // 깊은 복사
}

복사 생성자 Copy constructors
이미 존재하는 객체로 새 객체를 만들 때 호출되는 생성자

얕은 복사 
Vect v1(3);
Vect v2 = v1;   // ✅ 복사 생성자 호출
주소와 값이 같이 복사되어 delete를 두번 하게됨
오류 발생

깊은 복사 
Vect::Vect(const Vect& other) {
    size = other.size;
    data = new int[size];
    for (int i = 0; i < size; i++)
        data[i] = other.data[i];
}
새로운 메모리 공간에 값만 복사됨


대입 연산자 Assignment operator
이미 존재하는 객체에 다른 객체의 값을 대입할 때 호출되는 연산자

얕은 복사 
Vect v1(3);
Vect v2(5);
v2 = v1;   // ✅ 대입 연산자 호출
동일한 에러 발생

깊은 복사
Vect& Vect::operator=(const Vect& other) {
    if (this == &other) return *this;   // 자기 자신 대입 방지
    
    delete[] data;                      // 기존 메모리 해제
    size = other.size;
    data = new int[size];
    for (int i = 0; i < size; i++)
        data[i] = other.data[i];

    return *this;  // 자기 자신을 반환
}

아직 이해하지 못했으므로 다시 공부할것!!
